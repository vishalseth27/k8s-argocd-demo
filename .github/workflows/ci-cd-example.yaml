# Example CI/CD Pipeline for Microservices
# This is a template - uncomment and configure when ready for production

name: CI/CD Pipeline (Example - Not Active)

# Trigger conditions (currently disabled)
on:
  workflow_dispatch:  # Manual trigger only for now
  # Uncomment below when ready:
  # push:
  #   branches: [dev, main]
  #   tags:
  #     - 'v*'
  # pull_request:
  #   branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}

jobs:
  # Job 1: Build and Test Java Services
  build-and-test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [user-service, order-service]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'

      - name: Run Maven tests
        run: |
          cd services/${{ matrix.service }}
          mvn clean test

      - name: Build JAR
        run: |
          cd services/${{ matrix.service }}
          mvn clean package -DskipTests

      - name: Upload JAR artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.service }}-jar
          path: services/${{ matrix.service }}/target/*.jar
          retention-days: 7

  # Job 2: Build and Push Docker Images
  build-and-push-docker:
    needs: build-and-test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [user-service, order-service]

    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ matrix.service }}
          tags: |
            # Branch name
            type=ref,event=branch
            # PR number
            type=ref,event=pr
            # Version tags (v1.0.0)
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            # Git SHA
            type=sha,prefix={{branch}}-,format=short
            # Latest tag for main branch
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: services/${{ matrix.service }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Run Trivy vulnerability scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ matrix.service }}:sha-${{ github.sha }}
          format: 'sarif'
          output: 'trivy-results-${{ matrix.service }}.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results-${{ matrix.service }}.sarif'

  # Job 3: Update Kubernetes Manifests
  update-k8s-manifests:
    needs: build-and-push-docker
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine target environment
        id: env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/dev" ]]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "image_tag=dev-$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "image_tag=staging-$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" =~ ^refs/tags/v ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "image_tag=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          fi

      - name: Update Kustomization with new image tags
        if: steps.env.outputs.environment != ''
        run: |
          cd k8s/overlays/${{ steps.env.outputs.environment }}

          # Update image tags
          cat >> kustomization.yaml <<EOF

          images:
            - name: user-service
              newName: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/user-service
              newTag: ${{ steps.env.outputs.image_tag }}
            - name: order-service
              newName: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/order-service
              newTag: ${{ steps.env.outputs.image_tag }}
          EOF

      - name: Commit and push manifest changes
        if: steps.env.outputs.environment != ''
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add k8s/overlays/${{ steps.env.outputs.environment }}/
          git commit -m "Update ${{ steps.env.outputs.environment }} images to ${{ steps.env.outputs.image_tag }}"
          git push

  # Job 4: Deploy to Kubernetes (Optional - if not using ArgoCD auto-sync)
  deploy-to-kubernetes:
    needs: update-k8s-manifests
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request' && false  # Disabled - ArgoCD handles this

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure kubectl context
        run: |
          # Configure kubectl to point to your cluster
          # This would use secrets to authenticate
          echo "kubectl configuration would go here"

      - name: Deploy with kubectl
        run: |
          kubectl apply -k k8s/overlays/${{ steps.env.outputs.environment }}

      - name: Wait for rollout
        run: |
          kubectl rollout status rollout/user-service -n ${{ steps.env.outputs.environment }}
          kubectl rollout status rollout/order-service -n ${{ steps.env.outputs.environment }}

  # Job 5: Notification
  notify:
    needs: [build-and-test, build-and-push-docker, update-k8s-manifests]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Determine status
        id: status
        run: |
          if [[ "${{ needs.build-and-test.result }}" == "success" ]] && \
             [[ "${{ needs.build-and-push-docker.result }}" == "success" ]] && \
             [[ "${{ needs.update-k8s-manifests.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=✅" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "emoji=❌" >> $GITHUB_OUTPUT
          fi

      - name: Send notification
        run: |
          echo "${{ steps.status.outputs.emoji }} Pipeline ${{ steps.status.outputs.status }}"
          echo "Branch: ${{ github.ref }}"
          echo "Commit: ${{ github.sha }}"

          # Add Slack/Discord/Teams webhook here if needed
          # curl -X POST ${{ secrets.SLACK_WEBHOOK }} -d "..."
